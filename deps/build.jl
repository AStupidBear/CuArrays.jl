# discovering binary CUDA dependencies

using Pkg, Pkg.Artifacts
using CUDAapi, CUDAdrv


## discovery

# NOTE: we don't use autogenerated JLLs, because we have multiple artifacts and need to
#       decide at run time (i.e. not via package dependencies) which one to use.
const cuda_artifacts = Dict(
    v"10.2" => ()->artifact"CUDA10.2",
    v"10.1" => ()->artifact"CUDA10.1",
    v"10.0" => ()->artifact"CUDA10.0",
    v"9.2"  => ()->artifact"CUDA9.2",
    v"9.0"  => ()->artifact"CUDA9.0",
)

# utilities to look up stuff in the artifact (at known locations, so not using CUDAapi)
get_binary(artifact, name) = joinpath(artifact, "bin", Sys.iswindows() ? "$name.exe" : name)
function get_library(artifact, name)
    filename = if Sys.iswindows()
        "$name.dll"
    elseif Sys.isapple()
        "lib$name.dylib"
    else
        "lib$name.so"
    end
    joinpath(artifact, Sys.iswindows() ? "bin" : "lib", filename)
end

# try use CUDA from an artifact
function use_artifact_cuda()
    config = Dict{Symbol,Any}()

    if !parse(Bool, get(ENV, "JULIA_CUDA_USE_BINARYBUILDER", "true"))
        @warn "Use of CUDA artifacts not allowed by user"
        return
    end

    # select compatible artifacts
    if haskey(ENV, "JULIA_CUDA_VERSION")
        wanted_version = VersionNumber(ENV["JULIA_CUDA_VERSION"])
        filter!(((version,artifact),) -> version == wanted_version, cuda_artifacts)
    else
        if !CUDAdrv.functional()
            @error "CUDAdrv.jl is not functional, cannot select a compatible artifact."
            return
        end
        driver_version = CUDAdrv.release()
        filter!(((version,artifact),) -> version <= driver_version, cuda_artifacts)
    end

    # download and install
    artifact = nothing
    for release in sort(collect(keys(cuda_artifacts)); rev=true)
        try
            artifact = cuda_artifacts[release]()
            config[:toolkit_release] = release
            break
        catch
        end
    end
    if artifact == nothing
        @error "Could not find a compatible artifact."
        return
    end
    config[:toolkit_dirs] = [artifact]

    nvdisasm = get_binary(artifact, "nvdisasm")
    @assert isfile(nvdisasm)
    config[:toolkit_version] = parse_toolkit_version(nvdisasm)

    # discover libraries
    for name in  ("cublas", "cusparse", "cusolver", "cufft", "curand")
        handle = Symbol("lib$name")

        # on Windows, the library name is version dependent
        if Sys.iswindows()
            name *= if config[:toolkit_release] >= v"10.1"
                "64_$(config[:toolkit_release].major)"
            else
                "64_$(config[:toolkit_release].major)$(config[:toolkit_release].minor)"
            end
        end

        config[handle] = get_library(artifact, name)
        @assert isfile(config[handle])
    end

    @info "Found CUDA $(config[:toolkit_version]) from an artifact at $(join(config[:toolkit_dirs], ", "))"
    return config
end

# try to use CUDA from a local installation
function use_local_cuda()
    config = Dict{Symbol,Any}()

    dirs = find_toolkit()
    config[:toolkit_dirs] = dirs

    nvdisasm = find_cuda_binary("nvdisasm")
    if nvdisasm === nothing
        @error "Could not find nvdisasm"
        return
    end
    config[:toolkit_version] = parse_toolkit_version(config[:nvdisasm])
    config[:toolkit_release] = VersionNumber(config[:toolkit_version].major, config[:toolkit_version].minor)

    # discover libraries
    for name in  ("cublas", "cusparse", "cusolver", "cufft", "curand")
        handle = Symbol("lib$name")

        config[handle] = find_cuda_library(name, dirs, [version])
        if config[handle] === nothing
            @error "Could not find $name"
            return
        end
    end

    return config
end

const cudnn_artifacts = Dict(
    v"10.2" => ()->artifact"CUDNN+CUDA10.2",
    v"10.1" => ()->artifact"CUDNN+CUDA10.1",
    v"10.0" => ()->artifact"CUDNN+CUDA10.0",
    v"9.2"  => ()->artifact"CUDNN+CUDA9.2",
    v"9.0"  => ()->artifact"CUDNN+CUDA9.0",
)

function use_artifact_cudnn(config)
    artifact = try
        cudnn_artifacts[config[:toolkit_release]]()
    catch ex
        @error "Could not use CUDNN from artifacts" exception=(ex, catch_backtrace())
        return
    end

    path = get_library(artifact, Sys.iswindows() ? "cudnn64_7" : "cudnn")

    @info "Using CUDNN from an artifact at $(artifact)"
    return Dict(:libcudnn => path)
end

function use_local_cudnn(config)
    path = find_cuda_library("cudnn", prefix(), [v"7"])
    path === nothing && return

    @info "Found local CUDNN at $path"
    return Dict(:libcudnn => path)
end

const cutensor_artifacts = Dict(
    v"10.2" => ()->artifact"CUTENSOR+CUDA10.2",
    v"10.1" => ()->artifact"CUTENSOR+CUDA10.1",
)

function use_artifact_cutensor(config)
    artifact = try
        cutensor_artifacts[config[:toolkit_release]]()
    catch ex
        @error "Could not use CUTENSOR from artifacts" exception=(ex, catch_backtrace())
        return
    end

    path = get_library(artifact, "cutensor")

    @info "Using CUTENSOR from an artifact at $(artifact)"
    return Dict(:libcutensor => path)
end

function use_local_cutensor(config)
    path = find_cuda_library("cutensor", prefix(), [v"1"])
    path === nothing && return

    @info "Found local CUTENSOR at $path"
    return Dict(:libcutensor => path)
end


## main

const config_path = joinpath(@__DIR__, "deps.jl")

function write_deps(config, path)
    open(path, "w") do io
        println(io, "# autogenerated file, do not edit")
        for (key,val) in config
            println(io, "const $key = $(repr(val))")
        end
    end
end

function main()
    # initial state
    ispath(config_path) && rm(config_path; force=true)
    config = Dict{Symbol,Any}(:configured => false,
        :libcublas => nothing, :libcusparse => nothing, :libcusolver => nothing,
        :libcufft => nothing, :libcurand => nothing, :libcudnn => nothing,
        :libcutensor => nothing)   # actual values for ccall codegen
    write_deps(config, config_path)

    @info "Trying to use artifacts..."
    config = use_artifact_cuda()
    if config !== nothing
        merge!(config, something(use_artifact_cudnn(config), Dict(:libcudnn => nothing)))
        merge!(config, something(use_artifact_cutensor(config), Dict(:libcutensor => nothing)))
    end

    if config === nothing
        @info "Trying to use local installation..."
        config = use_local_cuda()
        if config !== nothing
            merge!(config, something(use_local_cudnn(config), Dict(:libcudnn => nothing)))
            merge!(config, something(use_local_cutensor(config), Dict(:libcutensor => nothing)))
        end
    end

    # successful configuration
    if config !== nothing
        config[:configured] = true
        write_deps(config, config_path)
    else
        @error "Could not find a suitable CUDA installation"
    end
end

main()
